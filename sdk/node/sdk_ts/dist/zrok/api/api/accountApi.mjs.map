{"version":3,"sources":["../../../../src/zrok/api/api/accountApi.ts","../../../../src/zrok/api/model/accessRequest.ts","../../../../src/zrok/api/model/accessResponse.ts","../../../../src/zrok/api/model/authUser.ts","../../../../src/zrok/api/model/configuration.ts","../../../../src/zrok/api/model/createFrontendRequest.ts","../../../../src/zrok/api/model/createFrontendResponse.ts","../../../../src/zrok/api/model/createIdentity201Response.ts","../../../../src/zrok/api/model/createIdentityRequest.ts","../../../../src/zrok/api/model/deleteFrontendRequest.ts","../../../../src/zrok/api/model/disableRequest.ts","../../../../src/zrok/api/model/enableRequest.ts","../../../../src/zrok/api/model/enableResponse.ts","../../../../src/zrok/api/model/environment.ts","../../../../src/zrok/api/model/environmentAndResources.ts","../../../../src/zrok/api/model/frontend.ts","../../../../src/zrok/api/model/inviteRequest.ts","../../../../src/zrok/api/model/inviteTokenGenerateRequest.ts","../../../../src/zrok/api/model/loginRequest.ts","../../../../src/zrok/api/model/metrics.ts","../../../../src/zrok/api/model/metricsSample.ts","../../../../src/zrok/api/model/overview.ts","../../../../src/zrok/api/model/passwordRequirements.ts","../../../../src/zrok/api/model/principal.ts","../../../../src/zrok/api/model/publicFrontend.ts","../../../../src/zrok/api/model/registerRequest.ts","../../../../src/zrok/api/model/registerResponse.ts","../../../../src/zrok/api/model/resetPasswordRequest.ts","../../../../src/zrok/api/model/resetPasswordRequestRequest.ts","../../../../src/zrok/api/model/share.ts","../../../../src/zrok/api/model/shareRequest.ts","../../../../src/zrok/api/model/shareResponse.ts","../../../../src/zrok/api/model/sparkDataSample.ts","../../../../src/zrok/api/model/unaccessRequest.ts","../../../../src/zrok/api/model/unshareRequest.ts","../../../../src/zrok/api/model/updateFrontendRequest.ts","../../../../src/zrok/api/model/updateShareRequest.ts","../../../../src/zrok/api/model/verifyRequest.ts","../../../../src/zrok/api/model/verifyResponse.ts","../../../../src/zrok/api/model/models.ts","../../../../src/zrok/api/api/adminApi.ts","../../../../src/zrok/api/api/environmentApi.ts","../../../../src/zrok/api/api/metadataApi.ts","../../../../src/zrok/api/api/shareApi.ts","../../../../src/zrok/api/api/apis.ts"],"sourcesContent":["/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport localVarRequest from 'request';\nimport http from 'http';\n\n/* tslint:disable:no-unused-locals */\nimport { InviteRequest } from '../model/inviteRequest';\nimport { LoginRequest } from '../model/loginRequest';\nimport { RegisterRequest } from '../model/registerRequest';\nimport { RegisterResponse } from '../model/registerResponse';\nimport { ResetPasswordRequest } from '../model/resetPasswordRequest';\nimport { ResetPasswordRequestRequest } from '../model/resetPasswordRequestRequest';\nimport { VerifyRequest } from '../model/verifyRequest';\nimport { VerifyResponse } from '../model/verifyResponse';\n\nimport { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';\nimport { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';\n\nimport { HttpError, RequestFile } from './apis';\n\nlet defaultBasePath = '/api/v1';\n\n// ===============================================\n// This file is autogenerated - Please do not edit\n// ===============================================\n\nexport enum AccountApiApiKeys {\n    key,\n}\n\nexport class AccountApi {\n    protected _basePath = defaultBasePath;\n    protected _defaultHeaders : any = {};\n    protected _useQuerystring : boolean = false;\n\n    protected authentications = {\n        'default': <Authentication>new VoidAuth(),\n        'key': new ApiKeyAuth('header', 'x-token'),\n    }\n\n    protected interceptors: Interceptor[] = [];\n\n    constructor(basePath?: string);\n    constructor(basePathOrUsername: string, password?: string, basePath?: string) {\n        if (password) {\n            if (basePath) {\n                this.basePath = basePath;\n            }\n        } else {\n            if (basePathOrUsername) {\n                this.basePath = basePathOrUsername\n            }\n        }\n    }\n\n    set useQuerystring(value: boolean) {\n        this._useQuerystring = value;\n    }\n\n    set basePath(basePath: string) {\n        this._basePath = basePath;\n    }\n\n    set defaultHeaders(defaultHeaders: any) {\n        this._defaultHeaders = defaultHeaders;\n    }\n\n    get defaultHeaders() {\n        return this._defaultHeaders;\n    }\n\n    get basePath() {\n        return this._basePath;\n    }\n\n    public setDefaultAuthentication(auth: Authentication) {\n        this.authentications.default = auth;\n    }\n\n    public setApiKey(key: AccountApiApiKeys, value: string) {\n        (this.authentications as any)[AccountApiApiKeys[key]].apiKey = value;\n    }\n\n    public addInterceptor(interceptor: Interceptor) {\n        this.interceptors.push(interceptor);\n    }\n\n    /**\n     * \n     * @param body \n     */\n    public async invite (body?: InviteRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {\n        const localVarPath = this.basePath + '/invite';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"InviteRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async login (body?: LoginRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {\n        const localVarPath = this.basePath + '/login';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"LoginRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"string\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async register (body?: RegisterRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RegisterResponse;  }> {\n        const localVarPath = this.basePath + '/register';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"RegisterRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: RegisterResponse;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"RegisterResponse\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async resetPassword (body?: ResetPasswordRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {\n        const localVarPath = this.basePath + '/resetPassword';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"ResetPasswordRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async resetPasswordRequest (body?: ResetPasswordRequestRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {\n        const localVarPath = this.basePath + '/resetPasswordRequest';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"ResetPasswordRequestRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async verify (body?: VerifyRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: VerifyResponse;  }> {\n        const localVarPath = this.basePath + '/verify';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"VerifyRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: VerifyResponse;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"VerifyResponse\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n}\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class AccessRequest {\n    'envZId'?: string;\n    'shrToken'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"envZId\",\n            \"baseName\": \"envZId\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"shrToken\",\n            \"baseName\": \"shrToken\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return AccessRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class AccessResponse {\n    'frontendToken'?: string;\n    'backendMode'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"frontendToken\",\n            \"baseName\": \"frontendToken\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"backendMode\",\n            \"baseName\": \"backendMode\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return AccessResponse.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class AuthUser {\n    'username'?: string;\n    'password'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"username\",\n            \"baseName\": \"username\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"password\",\n            \"baseName\": \"password\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return AuthUser.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\nimport { PasswordRequirements } from './passwordRequirements';\n\nexport class Configuration {\n    'version'?: string;\n    'touLink'?: string;\n    'invitesOpen'?: boolean;\n    'requiresInviteToken'?: boolean;\n    'inviteTokenContact'?: string;\n    'passwordRequirements'?: PasswordRequirements;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"version\",\n            \"baseName\": \"version\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"touLink\",\n            \"baseName\": \"touLink\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"invitesOpen\",\n            \"baseName\": \"invitesOpen\",\n            \"type\": \"boolean\"\n        },\n        {\n            \"name\": \"requiresInviteToken\",\n            \"baseName\": \"requiresInviteToken\",\n            \"type\": \"boolean\"\n        },\n        {\n            \"name\": \"inviteTokenContact\",\n            \"baseName\": \"inviteTokenContact\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"passwordRequirements\",\n            \"baseName\": \"passwordRequirements\",\n            \"type\": \"PasswordRequirements\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return Configuration.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class CreateFrontendRequest {\n    'zId'?: string;\n    'urlTemplate'?: string;\n    'publicName'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"zId\",\n            \"baseName\": \"zId\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"urlTemplate\",\n            \"baseName\": \"url_template\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"publicName\",\n            \"baseName\": \"public_name\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return CreateFrontendRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class CreateFrontendResponse {\n    'token'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"token\",\n            \"baseName\": \"token\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return CreateFrontendResponse.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class CreateIdentity201Response {\n    'identity'?: string;\n    'cfg'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"identity\",\n            \"baseName\": \"identity\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"cfg\",\n            \"baseName\": \"cfg\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return CreateIdentity201Response.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class CreateIdentityRequest {\n    'name'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"name\",\n            \"baseName\": \"name\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return CreateIdentityRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class DeleteFrontendRequest {\n    'frontendToken'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"frontendToken\",\n            \"baseName\": \"frontendToken\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return DeleteFrontendRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class DisableRequest {\n    'identity'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"identity\",\n            \"baseName\": \"identity\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return DisableRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class EnableRequest {\n    'description'?: string;\n    'host'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"description\",\n            \"baseName\": \"description\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"host\",\n            \"baseName\": \"host\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return EnableRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class EnableResponse {\n    'identity'?: string;\n    'cfg'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"identity\",\n            \"baseName\": \"identity\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"cfg\",\n            \"baseName\": \"cfg\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return EnableResponse.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\nimport { SparkDataSample } from './sparkDataSample';\n\nexport class Environment {\n    'description'?: string;\n    'host'?: string;\n    'address'?: string;\n    'zId'?: string;\n    'activity'?: Array<SparkDataSample>;\n    'limited'?: boolean;\n    'createdAt'?: number;\n    'updatedAt'?: number;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"description\",\n            \"baseName\": \"description\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"host\",\n            \"baseName\": \"host\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"address\",\n            \"baseName\": \"address\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"zId\",\n            \"baseName\": \"zId\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"activity\",\n            \"baseName\": \"activity\",\n            \"type\": \"Array<SparkDataSample>\"\n        },\n        {\n            \"name\": \"limited\",\n            \"baseName\": \"limited\",\n            \"type\": \"boolean\"\n        },\n        {\n            \"name\": \"createdAt\",\n            \"baseName\": \"createdAt\",\n            \"type\": \"number\"\n        },\n        {\n            \"name\": \"updatedAt\",\n            \"baseName\": \"updatedAt\",\n            \"type\": \"number\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return Environment.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\nimport { Environment } from './environment';\nimport { Frontend } from './frontend';\nimport { Share } from './share';\n\nexport class EnvironmentAndResources {\n    'environment'?: Environment;\n    'frontends'?: Array<Frontend>;\n    'shares'?: Array<Share>;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"environment\",\n            \"baseName\": \"environment\",\n            \"type\": \"Environment\"\n        },\n        {\n            \"name\": \"frontends\",\n            \"baseName\": \"frontends\",\n            \"type\": \"Array<Frontend>\"\n        },\n        {\n            \"name\": \"shares\",\n            \"baseName\": \"shares\",\n            \"type\": \"Array<Share>\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return EnvironmentAndResources.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class Frontend {\n    'id'?: number;\n    'shrToken'?: string;\n    'zId'?: string;\n    'createdAt'?: number;\n    'updatedAt'?: number;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"id\",\n            \"baseName\": \"id\",\n            \"type\": \"number\"\n        },\n        {\n            \"name\": \"shrToken\",\n            \"baseName\": \"shrToken\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"zId\",\n            \"baseName\": \"zId\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"createdAt\",\n            \"baseName\": \"createdAt\",\n            \"type\": \"number\"\n        },\n        {\n            \"name\": \"updatedAt\",\n            \"baseName\": \"updatedAt\",\n            \"type\": \"number\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return Frontend.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class InviteRequest {\n    'email'?: string;\n    'token'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"email\",\n            \"baseName\": \"email\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"token\",\n            \"baseName\": \"token\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return InviteRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class InviteTokenGenerateRequest {\n    'tokens'?: Array<string>;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"tokens\",\n            \"baseName\": \"tokens\",\n            \"type\": \"Array<string>\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return InviteTokenGenerateRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class LoginRequest {\n    'email'?: string;\n    'password'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"email\",\n            \"baseName\": \"email\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"password\",\n            \"baseName\": \"password\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return LoginRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\nimport { MetricsSample } from './metricsSample';\n\nexport class Metrics {\n    'scope'?: string;\n    'id'?: string;\n    'period'?: number;\n    'samples'?: Array<MetricsSample>;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"scope\",\n            \"baseName\": \"scope\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"id\",\n            \"baseName\": \"id\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"period\",\n            \"baseName\": \"period\",\n            \"type\": \"number\"\n        },\n        {\n            \"name\": \"samples\",\n            \"baseName\": \"samples\",\n            \"type\": \"Array<MetricsSample>\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return Metrics.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class MetricsSample {\n    'rx'?: number;\n    'tx'?: number;\n    'timestamp'?: number;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"rx\",\n            \"baseName\": \"rx\",\n            \"type\": \"number\"\n        },\n        {\n            \"name\": \"tx\",\n            \"baseName\": \"tx\",\n            \"type\": \"number\"\n        },\n        {\n            \"name\": \"timestamp\",\n            \"baseName\": \"timestamp\",\n            \"type\": \"number\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return MetricsSample.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\nimport { EnvironmentAndResources } from './environmentAndResources';\n\nexport class Overview {\n    'accountLimited'?: boolean;\n    'environments'?: Array<EnvironmentAndResources>;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"accountLimited\",\n            \"baseName\": \"accountLimited\",\n            \"type\": \"boolean\"\n        },\n        {\n            \"name\": \"environments\",\n            \"baseName\": \"environments\",\n            \"type\": \"Array<EnvironmentAndResources>\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return Overview.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class PasswordRequirements {\n    'length'?: number;\n    'requireCapital'?: boolean;\n    'requireNumeric'?: boolean;\n    'requireSpecial'?: boolean;\n    'validSpecialCharacters'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"length\",\n            \"baseName\": \"length\",\n            \"type\": \"number\"\n        },\n        {\n            \"name\": \"requireCapital\",\n            \"baseName\": \"requireCapital\",\n            \"type\": \"boolean\"\n        },\n        {\n            \"name\": \"requireNumeric\",\n            \"baseName\": \"requireNumeric\",\n            \"type\": \"boolean\"\n        },\n        {\n            \"name\": \"requireSpecial\",\n            \"baseName\": \"requireSpecial\",\n            \"type\": \"boolean\"\n        },\n        {\n            \"name\": \"validSpecialCharacters\",\n            \"baseName\": \"validSpecialCharacters\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return PasswordRequirements.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class Principal {\n    'id'?: number;\n    'email'?: string;\n    'token'?: string;\n    'limitless'?: boolean;\n    'admin'?: boolean;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"id\",\n            \"baseName\": \"id\",\n            \"type\": \"number\"\n        },\n        {\n            \"name\": \"email\",\n            \"baseName\": \"email\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"token\",\n            \"baseName\": \"token\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"limitless\",\n            \"baseName\": \"limitless\",\n            \"type\": \"boolean\"\n        },\n        {\n            \"name\": \"admin\",\n            \"baseName\": \"admin\",\n            \"type\": \"boolean\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return Principal.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class PublicFrontend {\n    'token'?: string;\n    'zId'?: string;\n    'urlTemplate'?: string;\n    'publicName'?: string;\n    'createdAt'?: number;\n    'updatedAt'?: number;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"token\",\n            \"baseName\": \"token\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"zId\",\n            \"baseName\": \"zId\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"urlTemplate\",\n            \"baseName\": \"urlTemplate\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"publicName\",\n            \"baseName\": \"publicName\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"createdAt\",\n            \"baseName\": \"createdAt\",\n            \"type\": \"number\"\n        },\n        {\n            \"name\": \"updatedAt\",\n            \"baseName\": \"updatedAt\",\n            \"type\": \"number\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return PublicFrontend.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class RegisterRequest {\n    'token'?: string;\n    'password'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"token\",\n            \"baseName\": \"token\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"password\",\n            \"baseName\": \"password\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return RegisterRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class RegisterResponse {\n    'token'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"token\",\n            \"baseName\": \"token\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return RegisterResponse.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class ResetPasswordRequest {\n    'token'?: string;\n    'password'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"token\",\n            \"baseName\": \"token\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"password\",\n            \"baseName\": \"password\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return ResetPasswordRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class ResetPasswordRequestRequest {\n    'emailAddress'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"emailAddress\",\n            \"baseName\": \"emailAddress\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return ResetPasswordRequestRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\nimport { SparkDataSample } from './sparkDataSample';\n\nexport class Share {\n    'token'?: string;\n    'zId'?: string;\n    'shareMode'?: string;\n    'backendMode'?: string;\n    'frontendSelection'?: string;\n    'frontendEndpoint'?: string;\n    'backendProxyEndpoint'?: string;\n    'reserved'?: boolean;\n    'activity'?: Array<SparkDataSample>;\n    'limited'?: boolean;\n    'createdAt'?: number;\n    'updatedAt'?: number;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"token\",\n            \"baseName\": \"token\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"zId\",\n            \"baseName\": \"zId\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"shareMode\",\n            \"baseName\": \"shareMode\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"backendMode\",\n            \"baseName\": \"backendMode\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"frontendSelection\",\n            \"baseName\": \"frontendSelection\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"frontendEndpoint\",\n            \"baseName\": \"frontendEndpoint\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"backendProxyEndpoint\",\n            \"baseName\": \"backendProxyEndpoint\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"reserved\",\n            \"baseName\": \"reserved\",\n            \"type\": \"boolean\"\n        },\n        {\n            \"name\": \"activity\",\n            \"baseName\": \"activity\",\n            \"type\": \"Array<SparkDataSample>\"\n        },\n        {\n            \"name\": \"limited\",\n            \"baseName\": \"limited\",\n            \"type\": \"boolean\"\n        },\n        {\n            \"name\": \"createdAt\",\n            \"baseName\": \"createdAt\",\n            \"type\": \"number\"\n        },\n        {\n            \"name\": \"updatedAt\",\n            \"baseName\": \"updatedAt\",\n            \"type\": \"number\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return Share.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\nimport { AuthUser } from './authUser';\n\nexport class ShareRequest {\n    'envZId'?: string;\n    'shareMode'?: ShareRequest.ShareModeEnum;\n    'frontendSelection'?: Array<string>;\n    'backendMode'?: ShareRequest.BackendModeEnum;\n    'backendProxyEndpoint'?: string;\n    'authScheme'?: string;\n    'authUsers'?: Array<AuthUser>;\n    'oauthProvider'?: ShareRequest.OauthProviderEnum;\n    'oauthEmailDomains'?: Array<string>;\n    'oauthAuthorizationCheckInterval'?: string;\n    'reserved'?: boolean;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"envZId\",\n            \"baseName\": \"envZId\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"shareMode\",\n            \"baseName\": \"shareMode\",\n            \"type\": \"ShareRequest.ShareModeEnum\"\n        },\n        {\n            \"name\": \"frontendSelection\",\n            \"baseName\": \"frontendSelection\",\n            \"type\": \"Array<string>\"\n        },\n        {\n            \"name\": \"backendMode\",\n            \"baseName\": \"backendMode\",\n            \"type\": \"ShareRequest.BackendModeEnum\"\n        },\n        {\n            \"name\": \"backendProxyEndpoint\",\n            \"baseName\": \"backendProxyEndpoint\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"authScheme\",\n            \"baseName\": \"authScheme\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"authUsers\",\n            \"baseName\": \"authUsers\",\n            \"type\": \"Array<AuthUser>\"\n        },\n        {\n            \"name\": \"oauthProvider\",\n            \"baseName\": \"oauthProvider\",\n            \"type\": \"ShareRequest.OauthProviderEnum\"\n        },\n        {\n            \"name\": \"oauthEmailDomains\",\n            \"baseName\": \"oauthEmailDomains\",\n            \"type\": \"Array<string>\"\n        },\n        {\n            \"name\": \"oauthAuthorizationCheckInterval\",\n            \"baseName\": \"oauthAuthorizationCheckInterval\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"reserved\",\n            \"baseName\": \"reserved\",\n            \"type\": \"boolean\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return ShareRequest.attributeTypeMap;\n    }\n}\n\nexport namespace ShareRequest {\n    export enum ShareModeEnum {\n        Public = <any> 'public',\n        Private = <any> 'private'\n    }\n    export enum BackendModeEnum {\n        Proxy = <any> 'proxy',\n        Web = <any> 'web',\n        TcpTunnel = <any> 'tcpTunnel',\n        UdpTunnel = <any> 'udpTunnel',\n        Caddy = <any> 'caddy'\n    }\n    export enum OauthProviderEnum {\n        Github = <any> 'github',\n        Google = <any> 'google'\n    }\n}\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class ShareResponse {\n    'frontendProxyEndpoints'?: Array<string>;\n    'shrToken'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"frontendProxyEndpoints\",\n            \"baseName\": \"frontendProxyEndpoints\",\n            \"type\": \"Array<string>\"\n        },\n        {\n            \"name\": \"shrToken\",\n            \"baseName\": \"shrToken\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return ShareResponse.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class SparkDataSample {\n    'rx'?: number;\n    'tx'?: number;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"rx\",\n            \"baseName\": \"rx\",\n            \"type\": \"number\"\n        },\n        {\n            \"name\": \"tx\",\n            \"baseName\": \"tx\",\n            \"type\": \"number\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return SparkDataSample.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class UnaccessRequest {\n    'frontendToken'?: string;\n    'envZId'?: string;\n    'shrToken'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"frontendToken\",\n            \"baseName\": \"frontendToken\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"envZId\",\n            \"baseName\": \"envZId\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"shrToken\",\n            \"baseName\": \"shrToken\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return UnaccessRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class UnshareRequest {\n    'envZId'?: string;\n    'shrToken'?: string;\n    'reserved'?: boolean;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"envZId\",\n            \"baseName\": \"envZId\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"shrToken\",\n            \"baseName\": \"shrToken\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"reserved\",\n            \"baseName\": \"reserved\",\n            \"type\": \"boolean\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return UnshareRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class UpdateFrontendRequest {\n    'frontendToken'?: string;\n    'publicName'?: string;\n    'urlTemplate'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"frontendToken\",\n            \"baseName\": \"frontendToken\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"publicName\",\n            \"baseName\": \"publicName\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"urlTemplate\",\n            \"baseName\": \"urlTemplate\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return UpdateFrontendRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class UpdateShareRequest {\n    'shrToken'?: string;\n    'backendProxyEndpoint'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"shrToken\",\n            \"baseName\": \"shrToken\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"backendProxyEndpoint\",\n            \"baseName\": \"backendProxyEndpoint\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return UpdateShareRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class VerifyRequest {\n    'token'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"token\",\n            \"baseName\": \"token\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return VerifyRequest.attributeTypeMap;\n    }\n}\n\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { RequestFile } from './models';\n\nexport class VerifyResponse {\n    'email'?: string;\n\n    static discriminator: string | undefined = undefined;\n\n    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [\n        {\n            \"name\": \"email\",\n            \"baseName\": \"email\",\n            \"type\": \"string\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return VerifyResponse.attributeTypeMap;\n    }\n}\n\n","import localVarRequest from 'request';\n\nexport * from './accessRequest';\nexport * from './accessResponse';\nexport * from './authUser';\nexport * from './configuration';\nexport * from './createFrontendRequest';\nexport * from './createFrontendResponse';\nexport * from './createIdentity201Response';\nexport * from './createIdentityRequest';\nexport * from './deleteFrontendRequest';\nexport * from './disableRequest';\nexport * from './enableRequest';\nexport * from './enableResponse';\nexport * from './environment';\nexport * from './environmentAndResources';\nexport * from './frontend';\nexport * from './inviteRequest';\nexport * from './inviteTokenGenerateRequest';\nexport * from './loginRequest';\nexport * from './metrics';\nexport * from './metricsSample';\nexport * from './overview';\nexport * from './passwordRequirements';\nexport * from './principal';\nexport * from './publicFrontend';\nexport * from './registerRequest';\nexport * from './registerResponse';\nexport * from './resetPasswordRequest';\nexport * from './resetPasswordRequestRequest';\nexport * from './share';\nexport * from './shareRequest';\nexport * from './shareResponse';\nexport * from './sparkDataSample';\nexport * from './unaccessRequest';\nexport * from './unshareRequest';\nexport * from './updateFrontendRequest';\nexport * from './updateShareRequest';\nexport * from './verifyRequest';\nexport * from './verifyResponse';\n\nimport * as fs from 'fs';\n\nexport interface RequestDetailedFile {\n    value: Buffer;\n    options?: {\n        filename?: string;\n        contentType?: string;\n    }\n}\n\nexport type RequestFile = string | Buffer | fs.ReadStream | RequestDetailedFile;\n\n\nimport { AccessRequest } from './accessRequest';\nimport { AccessResponse } from './accessResponse';\nimport { AuthUser } from './authUser';\nimport { Configuration } from './configuration';\nimport { CreateFrontendRequest } from './createFrontendRequest';\nimport { CreateFrontendResponse } from './createFrontendResponse';\nimport { CreateIdentity201Response } from './createIdentity201Response';\nimport { CreateIdentityRequest } from './createIdentityRequest';\nimport { DeleteFrontendRequest } from './deleteFrontendRequest';\nimport { DisableRequest } from './disableRequest';\nimport { EnableRequest } from './enableRequest';\nimport { EnableResponse } from './enableResponse';\nimport { Environment } from './environment';\nimport { EnvironmentAndResources } from './environmentAndResources';\nimport { Frontend } from './frontend';\nimport { InviteRequest } from './inviteRequest';\nimport { InviteTokenGenerateRequest } from './inviteTokenGenerateRequest';\nimport { LoginRequest } from './loginRequest';\nimport { Metrics } from './metrics';\nimport { MetricsSample } from './metricsSample';\nimport { Overview } from './overview';\nimport { PasswordRequirements } from './passwordRequirements';\nimport { Principal } from './principal';\nimport { PublicFrontend } from './publicFrontend';\nimport { RegisterRequest } from './registerRequest';\nimport { RegisterResponse } from './registerResponse';\nimport { ResetPasswordRequest } from './resetPasswordRequest';\nimport { ResetPasswordRequestRequest } from './resetPasswordRequestRequest';\nimport { Share } from './share';\nimport { ShareRequest } from './shareRequest';\nimport { ShareResponse } from './shareResponse';\nimport { SparkDataSample } from './sparkDataSample';\nimport { UnaccessRequest } from './unaccessRequest';\nimport { UnshareRequest } from './unshareRequest';\nimport { UpdateFrontendRequest } from './updateFrontendRequest';\nimport { UpdateShareRequest } from './updateShareRequest';\nimport { VerifyRequest } from './verifyRequest';\nimport { VerifyResponse } from './verifyResponse';\n\n/* tslint:disable:no-unused-variable */\nlet primitives = [\n                    \"string\",\n                    \"boolean\",\n                    \"double\",\n                    \"integer\",\n                    \"long\",\n                    \"float\",\n                    \"number\",\n                    \"any\"\n                 ];\n\nlet enumsMap: {[index: string]: any} = {\n        \"ShareRequest.ShareModeEnum\": ShareRequest.ShareModeEnum,\n        \"ShareRequest.BackendModeEnum\": ShareRequest.BackendModeEnum,\n        \"ShareRequest.OauthProviderEnum\": ShareRequest.OauthProviderEnum,\n}\n\nlet typeMap: {[index: string]: any} = {\n    \"AccessRequest\": AccessRequest,\n    \"AccessResponse\": AccessResponse,\n    \"AuthUser\": AuthUser,\n    \"Configuration\": Configuration,\n    \"CreateFrontendRequest\": CreateFrontendRequest,\n    \"CreateFrontendResponse\": CreateFrontendResponse,\n    \"CreateIdentity201Response\": CreateIdentity201Response,\n    \"CreateIdentityRequest\": CreateIdentityRequest,\n    \"DeleteFrontendRequest\": DeleteFrontendRequest,\n    \"DisableRequest\": DisableRequest,\n    \"EnableRequest\": EnableRequest,\n    \"EnableResponse\": EnableResponse,\n    \"Environment\": Environment,\n    \"EnvironmentAndResources\": EnvironmentAndResources,\n    \"Frontend\": Frontend,\n    \"InviteRequest\": InviteRequest,\n    \"InviteTokenGenerateRequest\": InviteTokenGenerateRequest,\n    \"LoginRequest\": LoginRequest,\n    \"Metrics\": Metrics,\n    \"MetricsSample\": MetricsSample,\n    \"Overview\": Overview,\n    \"PasswordRequirements\": PasswordRequirements,\n    \"Principal\": Principal,\n    \"PublicFrontend\": PublicFrontend,\n    \"RegisterRequest\": RegisterRequest,\n    \"RegisterResponse\": RegisterResponse,\n    \"ResetPasswordRequest\": ResetPasswordRequest,\n    \"ResetPasswordRequestRequest\": ResetPasswordRequestRequest,\n    \"Share\": Share,\n    \"ShareRequest\": ShareRequest,\n    \"ShareResponse\": ShareResponse,\n    \"SparkDataSample\": SparkDataSample,\n    \"UnaccessRequest\": UnaccessRequest,\n    \"UnshareRequest\": UnshareRequest,\n    \"UpdateFrontendRequest\": UpdateFrontendRequest,\n    \"UpdateShareRequest\": UpdateShareRequest,\n    \"VerifyRequest\": VerifyRequest,\n    \"VerifyResponse\": VerifyResponse,\n}\n\nexport class ObjectSerializer {\n    public static findCorrectType(data: any, expectedType: string) {\n        if (data == undefined) {\n            return expectedType;\n        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {\n            return expectedType;\n        } else if (expectedType === \"Date\") {\n            return expectedType;\n        } else {\n            if (enumsMap[expectedType]) {\n                return expectedType;\n            }\n\n            if (!typeMap[expectedType]) {\n                return expectedType; // w/e we don't know the type\n            }\n\n            // Check the discriminator\n            let discriminatorProperty = typeMap[expectedType].discriminator;\n            if (discriminatorProperty == null) {\n                return expectedType; // the type does not have a discriminator. use it.\n            } else {\n                if (data[discriminatorProperty]) {\n                    var discriminatorType = data[discriminatorProperty];\n                    if(typeMap[discriminatorType]){\n                        return discriminatorType; // use the type given in the discriminator\n                    } else {\n                        return expectedType; // discriminator did not map to a type\n                    }\n                } else {\n                    return expectedType; // discriminator was not present (or an empty string)\n                }\n            }\n        }\n    }\n\n    public static serialize(data: any, type: string) {\n        if (data == undefined) {\n            return data;\n        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {\n            return data;\n        } else if (type.lastIndexOf(\"Array<\", 0) === 0) { // string.startsWith pre es6\n            let subType: string = type.replace(\"Array<\", \"\"); // Array<Type> => Type>\n            subType = subType.substring(0, subType.length - 1); // Type> => Type\n            let transformedData: any[] = [];\n            for (let index = 0; index < data.length; index++) {\n                let datum = data[index];\n                transformedData.push(ObjectSerializer.serialize(datum, subType));\n            }\n            return transformedData;\n        } else if (type === \"Date\") {\n            return data.toISOString();\n        } else {\n            if (enumsMap[type]) {\n                return data;\n            }\n            if (!typeMap[type]) { // in case we dont know the type\n                return data;\n            }\n\n            // Get the actual type of this object\n            type = this.findCorrectType(data, type);\n\n            // get the map for the correct type.\n            let attributeTypes = typeMap[type].getAttributeTypeMap();\n            let instance: {[index: string]: any} = {};\n            for (let index = 0; index < attributeTypes.length; index++) {\n                let attributeType = attributeTypes[index];\n                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);\n            }\n            return instance;\n        }\n    }\n\n    public static deserialize(data: any, type: string) {\n        // polymorphism may change the actual type.\n        type = ObjectSerializer.findCorrectType(data, type);\n        if (data == undefined) {\n            return data;\n        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {\n            return data;\n        } else if (type.lastIndexOf(\"Array<\", 0) === 0) { // string.startsWith pre es6\n            let subType: string = type.replace(\"Array<\", \"\"); // Array<Type> => Type>\n            subType = subType.substring(0, subType.length - 1); // Type> => Type\n            let transformedData: any[] = [];\n            for (let index = 0; index < data.length; index++) {\n                let datum = data[index];\n                transformedData.push(ObjectSerializer.deserialize(datum, subType));\n            }\n            return transformedData;\n        } else if (type === \"Date\") {\n            return new Date(data);\n        } else {\n            if (enumsMap[type]) {// is Enum\n                return data;\n            }\n\n            if (!typeMap[type]) { // dont know the type\n                return data;\n            }\n            let instance = new typeMap[type]();\n            let attributeTypes = typeMap[type].getAttributeTypeMap();\n            for (let index = 0; index < attributeTypes.length; index++) {\n                let attributeType = attributeTypes[index];\n                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);\n            }\n            return instance;\n        }\n    }\n}\n\nexport interface Authentication {\n    /**\n    * Apply authentication settings to header and query params.\n    */\n    applyToRequest(requestOptions: localVarRequest.Options): Promise<void> | void;\n}\n\nexport class HttpBasicAuth implements Authentication {\n    public username: string = '';\n    public password: string = '';\n\n    applyToRequest(requestOptions: localVarRequest.Options): void {\n        requestOptions.auth = {\n            username: this.username, password: this.password\n        }\n    }\n}\n\nexport class HttpBearerAuth implements Authentication {\n    public accessToken: string | (() => string) = '';\n\n    applyToRequest(requestOptions: localVarRequest.Options): void {\n        if (requestOptions && requestOptions.headers) {\n            const accessToken = typeof this.accessToken === 'function'\n                            ? this.accessToken()\n                            : this.accessToken;\n            requestOptions.headers[\"Authorization\"] = \"Bearer \" + accessToken;\n        }\n    }\n}\n\nexport class ApiKeyAuth implements Authentication {\n    public apiKey: string = '';\n\n    constructor(private location: string, private paramName: string) {\n    }\n\n    applyToRequest(requestOptions: localVarRequest.Options): void {\n        if (this.location == \"query\") {\n            (<any>requestOptions.qs)[this.paramName] = this.apiKey;\n        } else if (this.location == \"header\" && requestOptions && requestOptions.headers) {\n            requestOptions.headers[this.paramName] = this.apiKey;\n        } else if (this.location == 'cookie' && requestOptions && requestOptions.headers) {\n            if (requestOptions.headers['Cookie']) {\n                requestOptions.headers['Cookie'] += '; ' + this.paramName + '=' + encodeURIComponent(this.apiKey);\n            }\n            else {\n                requestOptions.headers['Cookie'] = this.paramName + '=' + encodeURIComponent(this.apiKey);\n            }\n        }\n    }\n}\n\nexport class OAuth implements Authentication {\n    public accessToken: string = '';\n\n    applyToRequest(requestOptions: localVarRequest.Options): void {\n        if (requestOptions && requestOptions.headers) {\n            requestOptions.headers[\"Authorization\"] = \"Bearer \" + this.accessToken;\n        }\n    }\n}\n\nexport class VoidAuth implements Authentication {\n    public username: string = '';\n    public password: string = '';\n\n    applyToRequest(_: localVarRequest.Options): void {\n        // Do nothing\n    }\n}\n\nexport type Interceptor = (requestOptions: localVarRequest.Options) => (Promise<void> | void);\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport localVarRequest from 'request';\nimport http from 'http';\n\n/* tslint:disable:no-unused-locals */\nimport { CreateFrontendRequest } from '../model/createFrontendRequest';\nimport { CreateFrontendResponse } from '../model/createFrontendResponse';\nimport { CreateIdentity201Response } from '../model/createIdentity201Response';\nimport { CreateIdentityRequest } from '../model/createIdentityRequest';\nimport { DeleteFrontendRequest } from '../model/deleteFrontendRequest';\nimport { InviteTokenGenerateRequest } from '../model/inviteTokenGenerateRequest';\nimport { PublicFrontend } from '../model/publicFrontend';\nimport { UpdateFrontendRequest } from '../model/updateFrontendRequest';\n\nimport { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';\nimport { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';\n\nimport { HttpError, RequestFile } from './apis';\n\nlet defaultBasePath = '/api/v1';\n\n// ===============================================\n// This file is autogenerated - Please do not edit\n// ===============================================\n\nexport enum AdminApiApiKeys {\n    key,\n}\n\nexport class AdminApi {\n    protected _basePath = defaultBasePath;\n    protected _defaultHeaders : any = {};\n    protected _useQuerystring : boolean = false;\n\n    protected authentications = {\n        'default': <Authentication>new VoidAuth(),\n        'key': new ApiKeyAuth('header', 'x-token'),\n    }\n\n    protected interceptors: Interceptor[] = [];\n\n    constructor(basePath?: string);\n    constructor(basePathOrUsername: string, password?: string, basePath?: string) {\n        if (password) {\n            if (basePath) {\n                this.basePath = basePath;\n            }\n        } else {\n            if (basePathOrUsername) {\n                this.basePath = basePathOrUsername\n            }\n        }\n    }\n\n    set useQuerystring(value: boolean) {\n        this._useQuerystring = value;\n    }\n\n    set basePath(basePath: string) {\n        this._basePath = basePath;\n    }\n\n    set defaultHeaders(defaultHeaders: any) {\n        this._defaultHeaders = defaultHeaders;\n    }\n\n    get defaultHeaders() {\n        return this._defaultHeaders;\n    }\n\n    get basePath() {\n        return this._basePath;\n    }\n\n    public setDefaultAuthentication(auth: Authentication) {\n        this.authentications.default = auth;\n    }\n\n    public setApiKey(key: AdminApiApiKeys, value: string) {\n        (this.authentications as any)[AdminApiApiKeys[key]].apiKey = value;\n    }\n\n    public addInterceptor(interceptor: Interceptor) {\n        this.interceptors.push(interceptor);\n    }\n\n    /**\n     * \n     * @param body \n     */\n    public async createFrontend (body?: CreateFrontendRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreateFrontendResponse;  }> {\n        const localVarPath = this.basePath + '/frontend';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"CreateFrontendRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: CreateFrontendResponse;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"CreateFrontendResponse\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async createIdentity (body?: CreateIdentityRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreateIdentity201Response;  }> {\n        const localVarPath = this.basePath + '/identity';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"CreateIdentityRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: CreateIdentity201Response;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"CreateIdentity201Response\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async deleteFrontend (body?: DeleteFrontendRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {\n        const localVarPath = this.basePath + '/frontend';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'DELETE',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"DeleteFrontendRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async inviteTokenGenerate (body?: InviteTokenGenerateRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {\n        const localVarPath = this.basePath + '/invite/token/generate';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"InviteTokenGenerateRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     */\n    public async listFrontends (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<PublicFrontend>;  }> {\n        const localVarPath = this.basePath + '/frontends';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'GET',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: Array<PublicFrontend>;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"Array<PublicFrontend>\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async updateFrontend (body?: UpdateFrontendRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {\n        const localVarPath = this.basePath + '/frontend';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'PATCH',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"UpdateFrontendRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n}\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport localVarRequest from 'request';\nimport http from 'http';\n\n/* tslint:disable:no-unused-locals */\nimport { DisableRequest } from '../model/disableRequest';\nimport { EnableRequest } from '../model/enableRequest';\nimport { EnableResponse } from '../model/enableResponse';\n\nimport { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';\nimport { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';\n\nimport { HttpError, RequestFile } from './apis';\n\nlet defaultBasePath = '/api/v1';\n\n// ===============================================\n// This file is autogenerated - Please do not edit\n// ===============================================\n\nexport enum EnvironmentApiApiKeys {\n    key,\n}\n\nexport class EnvironmentApi {\n    protected _basePath = defaultBasePath;\n    protected _defaultHeaders : any = {};\n    protected _useQuerystring : boolean = false;\n\n    protected authentications = {\n        'default': <Authentication>new VoidAuth(),\n        'key': new ApiKeyAuth('header', 'x-token'),\n    }\n\n    protected interceptors: Interceptor[] = [];\n\n    constructor(basePath?: string);\n    constructor(basePathOrUsername: string, password?: string, basePath?: string) {\n        if (password) {\n            if (basePath) {\n                this.basePath = basePath;\n            }\n        } else {\n            if (basePathOrUsername) {\n                this.basePath = basePathOrUsername\n            }\n        }\n    }\n\n    set useQuerystring(value: boolean) {\n        this._useQuerystring = value;\n    }\n\n    set basePath(basePath: string) {\n        this._basePath = basePath;\n    }\n\n    set defaultHeaders(defaultHeaders: any) {\n        this._defaultHeaders = defaultHeaders;\n    }\n\n    get defaultHeaders() {\n        return this._defaultHeaders;\n    }\n\n    get basePath() {\n        return this._basePath;\n    }\n\n    public setDefaultAuthentication(auth: Authentication) {\n        this.authentications.default = auth;\n    }\n\n    public setApiKey(key: EnvironmentApiApiKeys, value: string) {\n        (this.authentications as any)[EnvironmentApiApiKeys[key]].apiKey = value;\n    }\n\n    public addInterceptor(interceptor: Interceptor) {\n        this.interceptors.push(interceptor);\n    }\n\n    /**\n     * \n     * @param body \n     */\n    public async disable (body?: DisableRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {\n        const localVarPath = this.basePath + '/disable';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"DisableRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async enable (body?: EnableRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: EnableResponse;  }> {\n        const localVarPath = this.basePath + '/enable';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"EnableRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: EnableResponse;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"EnableResponse\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n}\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport localVarRequest from 'request';\nimport http from 'http';\n\n/* tslint:disable:no-unused-locals */\nimport { Configuration } from '../model/configuration';\nimport { Environment } from '../model/environment';\nimport { EnvironmentAndResources } from '../model/environmentAndResources';\nimport { Frontend } from '../model/frontend';\nimport { Metrics } from '../model/metrics';\nimport { Overview } from '../model/overview';\nimport { Share } from '../model/share';\n\nimport { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';\nimport { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';\n\nimport { HttpError, RequestFile } from './apis';\n\nlet defaultBasePath = '/api/v1';\n\n// ===============================================\n// This file is autogenerated - Please do not edit\n// ===============================================\n\nexport enum MetadataApiApiKeys {\n    key,\n}\n\nexport class MetadataApi {\n    protected _basePath = defaultBasePath;\n    protected _defaultHeaders : any = {};\n    protected _useQuerystring : boolean = false;\n\n    protected authentications = {\n        'default': <Authentication>new VoidAuth(),\n        'key': new ApiKeyAuth('header', 'x-token'),\n    }\n\n    protected interceptors: Interceptor[] = [];\n\n    constructor(basePath?: string);\n    constructor(basePathOrUsername: string, password?: string, basePath?: string) {\n        if (password) {\n            if (basePath) {\n                this.basePath = basePath;\n            }\n        } else {\n            if (basePathOrUsername) {\n                this.basePath = basePathOrUsername\n            }\n        }\n    }\n\n    set useQuerystring(value: boolean) {\n        this._useQuerystring = value;\n    }\n\n    set basePath(basePath: string) {\n        this._basePath = basePath;\n    }\n\n    set defaultHeaders(defaultHeaders: any) {\n        this._defaultHeaders = defaultHeaders;\n    }\n\n    get defaultHeaders() {\n        return this._defaultHeaders;\n    }\n\n    get basePath() {\n        return this._basePath;\n    }\n\n    public setDefaultAuthentication(auth: Authentication) {\n        this.authentications.default = auth;\n    }\n\n    public setApiKey(key: MetadataApiApiKeys, value: string) {\n        (this.authentications as any)[MetadataApiApiKeys[key]].apiKey = value;\n    }\n\n    public addInterceptor(interceptor: Interceptor) {\n        this.interceptors.push(interceptor);\n    }\n\n    /**\n     * \n     */\n    public async configuration (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Configuration;  }> {\n        const localVarPath = this.basePath + '/configuration';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'GET',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n        };\n\n        let authenticationPromise = Promise.resolve();\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: Configuration;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"Configuration\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     */\n    public async getAccountDetail (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Environment>;  }> {\n        const localVarPath = this.basePath + '/detail/account';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'GET',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: Array<Environment>;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"Array<Environment>\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param duration \n     */\n    public async getAccountMetrics (duration?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Metrics;  }> {\n        const localVarPath = this.basePath + '/metrics/account';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        if (duration !== undefined) {\n            localVarQueryParameters['duration'] = ObjectSerializer.serialize(duration, \"string\");\n        }\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'GET',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: Metrics;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"Metrics\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param envZId \n     */\n    public async getEnvironmentDetail (envZId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: EnvironmentAndResources;  }> {\n        const localVarPath = this.basePath + '/detail/environment/{envZId}'\n            .replace('{' + 'envZId' + '}', encodeURIComponent(String(envZId)));\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        // verify required parameter 'envZId' is not null or undefined\n        if (envZId === null || envZId === undefined) {\n            throw new Error('Required parameter envZId was null or undefined when calling getEnvironmentDetail.');\n        }\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'GET',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: EnvironmentAndResources;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"EnvironmentAndResources\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param envId \n     * @param duration \n     */\n    public async getEnvironmentMetrics (envId: string, duration?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Metrics;  }> {\n        const localVarPath = this.basePath + '/metrics/environment/{envId}'\n            .replace('{' + 'envId' + '}', encodeURIComponent(String(envId)));\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        // verify required parameter 'envId' is not null or undefined\n        if (envId === null || envId === undefined) {\n            throw new Error('Required parameter envId was null or undefined when calling getEnvironmentMetrics.');\n        }\n\n        if (duration !== undefined) {\n            localVarQueryParameters['duration'] = ObjectSerializer.serialize(duration, \"string\");\n        }\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'GET',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: Metrics;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"Metrics\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param feId \n     */\n    public async getFrontendDetail (feId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Frontend;  }> {\n        const localVarPath = this.basePath + '/detail/frontend/{feId}'\n            .replace('{' + 'feId' + '}', encodeURIComponent(String(feId)));\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        // verify required parameter 'feId' is not null or undefined\n        if (feId === null || feId === undefined) {\n            throw new Error('Required parameter feId was null or undefined when calling getFrontendDetail.');\n        }\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'GET',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: Frontend;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"Frontend\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param shrToken \n     */\n    public async getShareDetail (shrToken: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Share;  }> {\n        const localVarPath = this.basePath + '/detail/share/{shrToken}'\n            .replace('{' + 'shrToken' + '}', encodeURIComponent(String(shrToken)));\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        // verify required parameter 'shrToken' is not null or undefined\n        if (shrToken === null || shrToken === undefined) {\n            throw new Error('Required parameter shrToken was null or undefined when calling getShareDetail.');\n        }\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'GET',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: Share;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"Share\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param shrToken \n     * @param duration \n     */\n    public async getShareMetrics (shrToken: string, duration?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Metrics;  }> {\n        const localVarPath = this.basePath + '/metrics/share/{shrToken}'\n            .replace('{' + 'shrToken' + '}', encodeURIComponent(String(shrToken)));\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        // verify required parameter 'shrToken' is not null or undefined\n        if (shrToken === null || shrToken === undefined) {\n            throw new Error('Required parameter shrToken was null or undefined when calling getShareMetrics.');\n        }\n\n        if (duration !== undefined) {\n            localVarQueryParameters['duration'] = ObjectSerializer.serialize(duration, \"string\");\n        }\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'GET',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: Metrics;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"Metrics\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     */\n    public async overview (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Overview;  }> {\n        const localVarPath = this.basePath + '/overview';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'GET',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: Overview;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"Overview\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     */\n    public async version (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {\n        const localVarPath = this.basePath + '/version';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'GET',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n        };\n\n        let authenticationPromise = Promise.resolve();\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"string\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n}\n","/**\n * zrok\n * zrok client access\n *\n * The version of the OpenAPI document: 0.3.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport localVarRequest from 'request';\nimport http from 'http';\n\n/* tslint:disable:no-unused-locals */\nimport { AccessRequest } from '../model/accessRequest';\nimport { AccessResponse } from '../model/accessResponse';\nimport { ShareRequest } from '../model/shareRequest';\nimport { ShareResponse } from '../model/shareResponse';\nimport { UnaccessRequest } from '../model/unaccessRequest';\nimport { UnshareRequest } from '../model/unshareRequest';\nimport { UpdateShareRequest } from '../model/updateShareRequest';\n\nimport { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';\nimport { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';\n\nimport { HttpError, RequestFile } from './apis';\n\nlet defaultBasePath = '/api/v1';\n\n// ===============================================\n// This file is autogenerated - Please do not edit\n// ===============================================\n\nexport enum ShareApiApiKeys {\n    key,\n}\n\nexport class ShareApi {\n    protected _basePath = defaultBasePath;\n    protected _defaultHeaders : any = {};\n    protected _useQuerystring : boolean = false;\n\n    protected authentications = {\n        'default': <Authentication>new VoidAuth(),\n        'key': new ApiKeyAuth('header', 'x-token'),\n    }\n\n    protected interceptors: Interceptor[] = [];\n\n    constructor(basePath?: string);\n    constructor(basePathOrUsername: string, password?: string, basePath?: string) {\n        if (password) {\n            if (basePath) {\n                this.basePath = basePath;\n            }\n        } else {\n            if (basePathOrUsername) {\n                this.basePath = basePathOrUsername\n            }\n        }\n    }\n\n    set useQuerystring(value: boolean) {\n        this._useQuerystring = value;\n    }\n\n    set basePath(basePath: string) {\n        this._basePath = basePath;\n    }\n\n    set defaultHeaders(defaultHeaders: any) {\n        this._defaultHeaders = defaultHeaders;\n    }\n\n    get defaultHeaders() {\n        return this._defaultHeaders;\n    }\n\n    get basePath() {\n        return this._basePath;\n    }\n\n    public setDefaultAuthentication(auth: Authentication) {\n        this.authentications.default = auth;\n    }\n\n    public setApiKey(key: ShareApiApiKeys, value: string) {\n        (this.authentications as any)[ShareApiApiKeys[key]].apiKey = value;\n    }\n\n    public addInterceptor(interceptor: Interceptor) {\n        this.interceptors.push(interceptor);\n    }\n\n    /**\n     * \n     * @param body \n     */\n    public async access (body?: AccessRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AccessResponse;  }> {\n        const localVarPath = this.basePath + '/access';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"AccessRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: AccessResponse;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"AccessResponse\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async share (body?: ShareRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ShareResponse;  }> {\n        const localVarPath = this.basePath + '/share';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'POST',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"ShareRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body: ShareResponse;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            body = ObjectSerializer.deserialize(body, \"ShareResponse\");\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async unaccess (body?: UnaccessRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {\n        const localVarPath = this.basePath + '/unaccess';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'DELETE',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"UnaccessRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async unshare (body?: UnshareRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {\n        const localVarPath = this.basePath + '/unshare';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        const produces = ['application/zrok.v1+json'];\n        // give precedence to 'application/json'\n        if (produces.indexOf('application/json') >= 0) {\n            localVarHeaderParams.Accept = 'application/json';\n        } else {\n            localVarHeaderParams.Accept = produces.join(',');\n        }\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'DELETE',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"UnshareRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * \n     * @param body \n     */\n    public async updateShare (body?: UpdateShareRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {\n        const localVarPath = this.basePath + '/share';\n        let localVarQueryParameters: any = {};\n        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);\n        let localVarFormParams: any = {};\n\n        (<any>Object).assign(localVarHeaderParams, options.headers);\n\n        let localVarUseFormData = false;\n\n        let localVarRequestOptions: localVarRequest.Options = {\n            method: 'PATCH',\n            qs: localVarQueryParameters,\n            headers: localVarHeaderParams,\n            uri: localVarPath,\n            useQuerystring: this._useQuerystring,\n            json: true,\n            body: ObjectSerializer.serialize(body, \"UpdateShareRequest\")\n        };\n\n        let authenticationPromise = Promise.resolve();\n        if (this.authentications.key.apiKey) {\n            authenticationPromise = authenticationPromise.then(() => this.authentications.key.applyToRequest(localVarRequestOptions));\n        }\n        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));\n\n        let interceptorPromise = authenticationPromise;\n        for (const interceptor of this.interceptors) {\n            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));\n        }\n\n        return interceptorPromise.then(() => {\n            if (Object.keys(localVarFormParams).length) {\n                if (localVarUseFormData) {\n                    (<any>localVarRequestOptions).formData = localVarFormParams;\n                } else {\n                    localVarRequestOptions.form = localVarFormParams;\n                }\n            }\n            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {\n                localVarRequest(localVarRequestOptions, (error, response, body) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {\n                            resolve({ response: response, body: body });\n                        } else {\n                            reject(new HttpError(response, body, response.statusCode));\n                        }\n                    }\n                });\n            });\n        });\n    }\n}\n","export * from './accountApi';\nimport { AccountApi } from './accountApi';\nexport * from './adminApi';\nimport { AdminApi } from './adminApi';\nexport * from './environmentApi';\nimport { EnvironmentApi } from './environmentApi';\nexport * from './metadataApi';\nimport { MetadataApi } from './metadataApi';\nexport * from './shareApi';\nimport { ShareApi } from './shareApi';\nimport * as http from 'http';\n\nexport class HttpError extends Error {\n    constructor (public response: http.IncomingMessage, public body: any, public statusCode?: number) {\n        super('HTTP request failed');\n        this.name = 'HttpError';\n    }\n}\n\nexport { RequestFile } from '../model/models';\n\nexport const APIS = [AccountApi, AdminApi, EnvironmentApi, MetadataApi, ShareApi];\n"],"mappings":"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","names":["localVarRequest","ShareRequest","ShareModeEnum","BackendModeEnum","OauthProviderEnum","localVarRequest","localVarRequest","localVarRequest","AccountApiApiKeys","localVarRequest","body"]}